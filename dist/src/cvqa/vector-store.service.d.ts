import { PrismaService } from '../prisma/prisma.service';
import { CacheService } from '../common/cache.service';
export type RetrievedChunk = {
    id: string;
    documentId: string;
    chunkIndex: number;
    text: string;
    distance: number;
    title: string | null;
    originalName: string | null;
    technicianSelectionCount?: number;
    boostedScore?: number;
};
export type DocumentRelevance = {
    documentId: string;
    similarity: number;
    title: string | null;
    originalName: string | null;
};
export type WorkOrderRelevance = {
    workOrderId: string;
    otNumber: string;
    similarity: number;
    summary: string | null;
};
export declare class VectorStoreService {
    private readonly prisma;
    private readonly cacheService;
    private readonly logger;
    private readonly projectId;
    private readonly location;
    private readonly embeddingModel;
    private readonly predictionClient;
    private readonly rerankModel;
    private readonly infraReady;
    private readonly vectorBackend;
    private readonly supabase;
    private readonly vectorBucketName;
    private readonly chunkIndexName;
    private readonly summaryIndexName;
    private readonly workOrderSummaryIndexName;
    private readonly vectorSchema;
    private readonly queryEmbeddingCache;
    constructor(prisma: PrismaService, cacheService: CacheService);
    indexDocumentSummary(documentId: string, summary: string): Promise<void>;
    indexWorkOrderSummary(workOrderId: string, summary: string): Promise<void>;
    indexDocument(documentId: string, text: string, options?: {
        chunkTokens?: number;
        overlapTokens?: number;
    }): Promise<void>;
    processPendingEmbeddings(batchLimit?: number): Promise<number>;
    private embedChunkBatchForDocument;
    search(query: string, documentIds: string[], topK?: number, organizationId?: string): Promise<RetrievedChunk[]>;
    private applyTechnicianSelectionBoost;
    private markSupabaseDocsPendingIfChunksExist;
    getEmbeddingStatus(documentId: string): Promise<string | null>;
    isDocumentEmbedded(documentId: string): Promise<boolean>;
    isSummaryIndexed(documentId: string): Promise<boolean>;
    private findMostRelevantDocuments;
    private ensurePgVectorInfrastructure;
    private ensureSupabaseVectorInfrastructure;
    private resolveWorkOrderSummaryIndexName;
    private embedBatchEfficient;
    private buildEmbeddingBatches;
    private embedBatchWithAdaptiveSizing;
    private callVertexEmbedding;
    embedQuery(query: string, organizationId?: string): Promise<number[]>;
    private chunkText;
    private splitIntoSections;
    private splitLargeSection;
    private mergeUpTo;
    private extractEmbedding;
    private countTokensApprox;
    private estimateEmbeddingTokens;
    private rerankChunks;
    private cosineSimilarity;
    private isMissingCosineDistanceOperator;
    private distanceToSimilarity;
    private toVectorLiteral;
    private resolveVectorBucketName;
    private resolveChunkIndexName;
    private resolveSummaryIndexName;
    private resolveVectorSchema;
    private getVectorsClient;
    private getVectorBucketScope;
    private getChunkIndexScope;
    private getSummaryIndexScope;
    private getWorkOrderSummaryIndexScope;
    private buildChunkVectorKey;
    private parseChunkVectorKey;
    private schemaIdentifier;
    private tableIdentifier;
    private vectorTable;
    private insertPendingChunks;
    private replaceChunkEmbeddings;
    private replaceChunkEmbeddingsSupabase;
    private deleteVectorKeys;
    private putVectorsInBatches;
    private chunkArray;
    private upsertSummaryEmbedding;
    private upsertWorkOrderSummaryEmbedding;
    private searchChunkEmbeddings;
    private searchChunkEmbeddingsSupabase;
    embedTexts(texts: string[], options?: {
        taskType?: 'RETRIEVAL_DOCUMENT' | 'RETRIEVAL_QUERY';
        organizationId?: string;
    }): Promise<number[][]>;
    private buildCacheKey;
    private isSupabaseVectorConflict;
    private delay;
    private extractErrorMessage;
    private isInvalidArgumentError;
    private isRetryableEmbeddingError;
    private getEmbeddingRetryDelay;
    searchDocumentsByRelevance(query: string, documentIds: string[], topK?: number, organizationId?: string): Promise<DocumentRelevance[]>;
    searchWorkOrderSummaries(query: string, topK?: number, organizationId?: string): Promise<WorkOrderRelevance[]>;
    private searchChunkEmbeddingsInMemory;
    private searchWorkOrderEmbeddingsInMemory;
    private parsePgVectorText;
}
